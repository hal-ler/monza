; Copyright Microsoft and Project Monza Contributors.
; SPDX-License-Identifier: MIT

global kernel_enter
global abort_kernel_callback
global compartment_enter
global compartment_return
global compartment_exit

extern compartment_forward_exit
extern compartment_forward_alloc_chunk
extern compartment_forward_alloc_meta_data
extern compartment_forward_dealloc_chunk
extern compartment_forward_callback

extern kernel_pagetable

%include "macros.asm"

; Save the callee-saved registers on the stack.
%macro save_registers 0
    sub rsp, REGS_END
    mov [rsp + RBX_OFFSET], rbx
    mov [rsp + RBP_OFFSET], rbp
    mov [rsp + R12_OFFSET], r12
    mov [rsp + R13_OFFSET], r13
    mov [rsp + R14_OFFSET], r14
    mov [rsp + R15_OFFSET], r15
%endmacro

; Restore the callee-saved registers from the stack.
%macro restore_registers 0
    mov rbx, [rsp + RBX_OFFSET]
    mov rbp, [rsp + RBP_OFFSET]
    mov r12, [rsp + R12_OFFSET]
    mov r13, [rsp + R13_OFFSET]
    mov r14, [rsp + R14_OFFSET]
    mov r15, [rsp + R15_OFFSET]
    add rsp, REGS_END
%endmacro

; Save the kernel state to be restored on kernel_enter onto the stack.
; Arguments are:
;   - register containing the last stored stack pointer
;   - register containing the pointer to CompartmentBase
%macro save_kernel_state 2
    save_registers
    pushf
    push %1
    push %2
%endmacro

; Restore the kernel state as part of kernel_enter.
; Arguments are:
;   - register into which to store the last stored stack pointer
;   - register into which to store the pointer to CompartmentBase
%macro restore_kernel_state 2
    pop %2
    pop %1
    popf
    restore_registers
%endmacro

; Retrieve the CompartmentBase pointer from the kernel state.
; Argument is register into which to store the pointer to CompartmentBase.
%macro get_compartment_from_state 1
    mov %1, [rsp]
%endmacro

; Save the compartment state to be restored on compartment_resume onto the stack.
; Argument is register which contains compartment RFLAGS.
%macro save_compartment_state 1
    ;save_registers
    push %1
%endmacro

; Restore the compartment state as part of compartment_resume.
; This macro will also clear the state from the stack.
%macro restore_compartment_state 0
    popf
    ;restore_registers
%endmacro

section .text
; void* compartment_enter(void* lambda, void* ret, void* data, void* fp, void* sp, Compartment* self)
; Implemented in assembly to fully control transition code.
compartment_enter:
    ; Get the last stored stack pointer so that it can be pushed onto the stack
    get_thread_execution_context_entry r10
    mov r11, [r10 + THREAD_EXECUTION_CONTEXT_LAST_SP_OFFSET]

    ; lambda, ret, data are the arguments needed for fp, so just preserve RDI, RSI, RDX
    ; Just for reference: fp in RCX, sp in R8, self in R9
    ; Save registers to be restored after kernel_enter on the stack
    save_kernel_state r11, r9

    ; Store the current stack pointer to be reset on kernel_enter
    get_thread_execution_context_entry r10
    mov [r10 + THREAD_EXECUTION_CONTEXT_LAST_SP_OFFSET], rsp

    ; Switch the TLS
    mov rax, [r9 + COMPARTMENTBASE_TLS_OFFSET]
    set_tls_base_macro rax

    ; Switch CR3
    mov rax, [r9 + COMPARTMENTBASE_PAGETABLE_OFFSET]
    mov cr3, rax

    ; We set up the target address in RAX for our stub
    mov rax, rcx

    ; Set up sysret arguments and use sysret to change over to ring 3
    mov rcx, .compartment_stub
    mov r11, CLEAN_RFLAGS
    o64 sysret

; This part of the function will execute in ring 3
.compartment_stub:
    ; Only switch the stack pointer in ring 3 to avoid the race with interrupts in ring 0
    mov rsp, r8
    ; Clear r8 and push to ensure rsp+8 aligns to 16 bytes as required by the ABI
    xor r8, r8
    push r8
    ; The syscall generated by compartment_return will tail-call out of compartment_enter
    jmp rax

; void* compartment_resume(void* ret, void* sp, CompartmentBase* self)
; Implemented in assembly to fully control transition code.
; As compared to compartment_enter, there is no need to save the kernel state.
compartment_resume:
    ; Switch the TLS
    mov rax, [rdx + COMPARTMENTBASE_TLS_OFFSET]
    set_tls_base_macro rax

    ; Switch CR3
    mov rax, [rdx + COMPARTMENTBASE_PAGETABLE_OFFSET]
    mov cr3, rax

    ; Set up return value in RAX
    mov rax, rdi

    ; Set up sysret arguments and use sysret to change over to ring 3
    mov rcx, .compartment_stub
    mov r11, CLEAN_RFLAGS
    o64 sysret

; This part of the function will execute in ring 3
.compartment_stub:
    ; Only switch the stack pointer in ring 3 to avoid the race with interrupts in ring 0
    mov rsp, rsi
    ; Restore the compartment state
    restore_compartment_state
    ; Tail-call out of syscall
    ret

; void abort_kernel_callback(int status)
; Stop executing the kernel code and resume as if the last compartment exited with an error.
abort_kernel_callback:
    ; Move argument to rsi as it will be used as second argument to compartment_forward_exit.
    mov rsi, rdi

    ; Reset the kernel state to match the last call to compartment_enter.
    get_thread_execution_context_entry r10
    mov rsp, [r10 + THREAD_EXECUTION_CONTEXT_LAST_SP_OFFSET]
    restore_kernel_state r11, rdi
    mov [r10 + THREAD_EXECUTION_CONTEXT_LAST_SP_OFFSET], r11

    ; Notify the compartment object of the error.
    call compartment_forward_exit
    mov rax, 0x0
    ; Tail-return out of compartment_enter
    ret

; void* kernel_enter(uint64_t reason, up to five args that will be passed to subsequent calls)
; Implemented in assembly to fully control transition code.
; R10 contains the second syscall argument instead of RCX.
; RCX contains the compartment return address and R11 contains the compartment RFLAGS.
kernel_enter:
    save_compartment_state r11
    mov rcx, r10

    ; Switch CR3 to the kernel one.
    mov rax, [kernel_pagetable]
    mov cr3, rax

    ; Ensure that the per-core data pointer is correct
    reset_per_core_pointer

    ; Switch the TLS and stack pointers to the kernel ones.
    ; Keep compartment RSP in R11 if we need to return to it later on.
    get_thread_execution_context_entry r10
    mov r11, rsp
    mov rsp, [r10 + THREAD_EXECUTION_CONTEXT_LAST_SP_OFFSET]
    mov rax, [r10 + THREAD_EXECUTION_CONTEXT_TLS_OFFSET]
    set_tls_base_macro rax

    ; Switch for reason to enter kernel, default is to process compartment exit.
    ; Check reasons for compartment_return.
    cmp rdi, SYSCALL_COMPARTMENT_RETURN
    jne .not_return
.return:
    ; Handle compartment_return.
    ; Restore the saved registers
    restore_kernel_state r11, rax
    mov [r10 + THREAD_EXECUTION_CONTEXT_LAST_SP_OFFSET], r11
    mov rax, 0x1
    ; Tail-return out of compartment_enter
    ret
.not_return:
    ; Check reasons for compartment_alloc_chunk.
    cmp rdi, SYSCALL_COMPARTMENT_ALLOC_CHUNK
    jne .not_alloc_chunk
    ; Handle compartment_alloc_chunk.
    get_compartment_from_state rdi
    push r11
    call compartment_forward_alloc_chunk
    pop r11
    mov rdi, rax
    mov rsi, r11
    get_compartment_from_state rdx
    jmp compartment_resume
.not_alloc_chunk:
    ; Check reasons for compartment_alloc_meta_data.
    cmp rdi, SYSCALL_COMPARTMENT_ALLOC_META_DATA
    jne .not_alloc_meta_data
    ; Handle compartment_alloc_metadata.
    get_compartment_from_state rdi
    push r11
    call compartment_forward_alloc_meta_data
    pop r11
    mov rdi, rax
    mov rsi, r11
    get_compartment_from_state rdx
    jmp compartment_resume
.not_alloc_meta_data:
    ; Check reasons for compartment_dealloc_chunk.
    cmp rdi, SYSCALL_COMPARTMENT_DEALLOC_CHUNK
    jne .not_dealloc_chunk
    ; Handle compartment_set_metadata.
    get_compartment_from_state rdi
    push r11
    call compartment_forward_dealloc_chunk
    pop r11
    mov rdi, rax
    mov rsi, r11
    get_compartment_from_state rdx
    jmp compartment_resume
.not_dealloc_chunk:
    ; Check reasons for compartment_callback.
    cmp rdi, SYSCALL_COMPARTMENT_CALLBACK
    jne .default
; Handle compartment_callback.
    get_compartment_from_state rdi
    push r11
    call compartment_forward_callback
    pop r11
    mov rdi, rax
    mov rsi, r11
    get_compartment_from_state rdx
    jmp compartment_resume
.default:
    ; Default reason is compartment_exit.
    ; Restore the saved registers
    restore_kernel_state r11, rdi
    mov [r10 + THREAD_EXECUTION_CONTEXT_LAST_SP_OFFSET], r11
    call compartment_forward_exit
    mov rax, 0x0
    ; Tail-return out of compartment_enter
    ret

; Matches Syscalls enum in syscall.h.
SYSCALL_COMPARTMENT_EXIT            EQU 0
SYSCALL_COMPARTMENT_RETURN          EQU 1
SYSCALL_COMPARTMENT_ALLOC_CHUNK     EQU 2
SYSCALL_COMPARTMENT_ALLOC_META_DATA EQU 3
SYSCALL_COMPARTMENT_DEALLOC_CHUNK   EQU 4 
SYSCALL_COMPARTMENT_CALLBACK        EQU 5

; Matches class CompartmentBase in compartment.h.
COMPARTMENTBASE_PAGETABLE_OFFSET    EQU 0x0
COMPARTMENTBASE_TLS_OFFSET          EQU 0x8

CLEAN_RFLAGS    EQU 0x202

RBX_OFFSET      EQU 0
RBP_OFFSET      EQU 0x8
R12_OFFSET      EQU 0x10
R13_OFFSET      EQU 0x18
R14_OFFSET      EQU 0x20
R15_OFFSET      EQU 0x28
REGS_END        EQU 0x30

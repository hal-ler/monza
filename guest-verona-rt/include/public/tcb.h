// Copyright Microsoft and Project Monza Contributors.
// SPDX-License-Identifier: MIT

#pragma once

#include <cstdint>

namespace monza
{
  class ArchitecturalCompartmentBase;

  /**
   * CompartmentOwner is a non-dereferencable identifier to a compartment
   * instance. Its value is generated by CompartmentBase::get_owner(). Equality
   * between two CompartmentOwner values means that they were generated from the
   * same compartment instance.
   */
  class CompartmentOwner
  {
    constexpr static uintptr_t NULL_ID = 0;
    uintptr_t id;

  public:
    inline bool operator==(const CompartmentOwner& other) const
    {
      return id == other.id;
    }

    inline bool operator!=(const CompartmentOwner& other) const
    {
      return id != other.id;
    }

    /**
     * Used in Debug to print error messages.
     */
    uintptr_t as_uintptr_t()
    {
      return id;
    }

    /**
     * Special marker value to signal that no compartment owns an entity and
     * instead ownership lies with Monza core.
     */
    static consteval CompartmentOwner null()
    {
      return CompartmentOwner(NULL_ID);
    }

  private:
    /**
     * Should only be called from CompartmentBase::get_owner().
     * Logic to convert reference to id resides there.
     */
    constexpr CompartmentOwner(uintptr_t id) : id(id) {}

    friend class ArchitecturalCompartmentBase;
  };

  struct TCB
  {
    void* self_ptr;
    void* stack_limit_low;
    void* stack_limit_high;
    CompartmentOwner compartment;
  };

  TCB* get_tcb();

  /**
   * Check if the current execution context is within a compartment.
   * This is not a security check when running inside a compartment!
   * A compromised compartment can force this to return false.
   */
  inline bool is_compartment()
  {
    TCB* tcb = get_tcb();
    if (tcb == nullptr)
    {
      return false;
    }
    return tcb->compartment != CompartmentOwner::null();
  }

  /**
   * Check if the current execution context matches a given compartment.
   * This is not a security check when running inside a compartment!
   * A compromised compartment can force this to return true.
   */
  inline bool matches_compartment(CompartmentOwner compartment)
  {
    TCB* tcb = get_tcb();
    if (tcb == nullptr)
    {
      return false;
    }
    return tcb->compartment == compartment;
  }
}
